/**
 * filesize
 *
 * @copyright 2023 Jason Mulligan <jason.mulligan@avoidwork.com>
 * @license BSD-3-Clause
 * @version 10.0.7
 */
const ARRAY="array",BIT="bit",BITS="bits",BYTE="byte",BYTES="bytes",EMPTY="",EXPONENT="exponent",FUNCTION="function",IEC="iec",INVALID_NUMBER="Invalid number",INVALID_ROUND="Invalid rounding method",JEDEC="jedec",OBJECT="object",PERIOD=".",ROUND="round",S="s",SI_KBIT="kbit",SI_KBYTE="kB",SPACE=" ",STRING="string",ZERO="0",STRINGS={symbol:{iec:{bits:["bit","Kibit","Mibit","Gibit","Tibit","Pibit","Eibit","Zibit","Yibit"],bytes:["B","KiB","MiB","GiB","TiB","PiB","EiB","ZiB","YiB"]},jedec:{bits:["bit","Kbit","Mbit","Gbit","Tbit","Pbit","Ebit","Zbit","Ybit"],bytes:["B","KB","MB","GB","TB","PB","EB","ZB","YB"]}},fullform:{iec:["","kibi","mebi","gibi","tebi","pebi","exbi","zebi","yobi"],jedec:["","kilo","mega","giga","tera","peta","exa","zetta","yotta"]}};function filesize(arg,{bits:bits=!1,pad:pad=!1,base:base=-1,round:round=2,locale:locale=EMPTY,localeOptions:localeOptions={},separator:separator=EMPTY,spacer:spacer=SPACE,symbols:symbols={},standard:standard=EMPTY,output:output=STRING,fullform:fullform=!1,fullforms:fullforms=[],exponent:exponent=-1,roundingMethod:roundingMethod=ROUND,precision:precision=0}={}){let e=exponent,num=Number(arg),result=[],val=0,u=EMPTY;-1===base&&0===standard.length?(base=10,standard=JEDEC):-1===base&&standard.length>0?base=(standard=standard===IEC?IEC:JEDEC)===IEC?2:10:standard=10===(base=2===base?2:10)||standard===JEDEC?JEDEC:IEC;const ceil=10===base?1e3:1024,full=!0===fullform,neg=num<0,roundingFunc=Math[roundingMethod];if("bigint"!=typeof arg&&isNaN(arg))throw new TypeError(INVALID_NUMBER);if(typeof roundingFunc!==FUNCTION)throw new TypeError(INVALID_ROUND);if(neg&&(num=-num),(-1===e||isNaN(e))&&(e=Math.floor(Math.log(num)/Math.log(ceil)),e<0&&(e=0)),e>8&&(precision>0&&(precision+=8-e),e=8),output===EXPONENT)return e;if(0===num)result[0]=0,u=result[1]=STRINGS.symbol[standard][bits?BITS:BYTES][e];else{val=num/(2===base?Math.pow(2,10*e):Math.pow(1e3,e)),bits&&(val*=8,val>=ceil&&e<8&&(val/=ceil,e++));const p=Math.pow(10,e>0?round:0);result[0]=roundingFunc(val*p)/p,result[0]===ceil&&e<8&&-1===exponent&&(result[0]=1,e++),u=result[1]=10===base&&1===e?bits?SI_KBIT:SI_KBYTE:STRINGS.symbol[standard][bits?BITS:BYTES][e]}if(neg&&(result[0]=-result[0]),precision>0&&(result[0]=result[0].toPrecision(precision)),result[1]=symbols[result[1]]||result[1],!0===locale?result[0]=result[0].toLocaleString():locale.length>0?result[0]=result[0].toLocaleString(locale,localeOptions):separator.length>0&&(result[0]=result[0].toString().replace(PERIOD,separator)),pad&&!1===Number.isInteger(result[0])&&round>0){const x=separator||PERIOD,tmp=result[0].toString().split(x),s=tmp[1]||EMPTY,l=s.length,n=round-l;result[0]=`${tmp[0]}${x}${s.padEnd(l+n,ZERO)}`}return full&&(result[1]=fullforms[e]?fullforms[e]:STRINGS.fullform[standard][e]+(bits?BIT:BYTE)+(1===result[0]?EMPTY:S)),output===ARRAY?result:output===OBJECT?{value:result[0],symbol:result[1],exponent:e,unit:u}:result.join(spacer)}function partial({bits:bits=!1,pad:pad=!1,base:base=-1,round:round=2,locale:locale=EMPTY,localeOptions:localeOptions={},separator:separator=EMPTY,spacer:spacer=SPACE,symbols:symbols={},standard:standard=EMPTY,output:output=STRING,fullform:fullform=!1,fullforms:fullforms=[],exponent:exponent=-1,roundingMethod:roundingMethod=ROUND,precision:precision=0}={}){return arg=>filesize(arg,{bits:bits,pad:pad,base:base,round:round,locale:locale,localeOptions:localeOptions,separator:separator,spacer:spacer,symbols:symbols,standard:standard,output:output,fullform:fullform,fullforms:fullforms,exponent:exponent,roundingMethod:roundingMethod,precision:precision})}export{filesize,partial};